# Generated by CodiumAI
import pytest
from flask import url_for
from requests import patch


"""
Code Analysis

Objective:
The objective of the "index" function is to retrieve and display the transaction history of the current user, including their deposits, withdrawals, and interest earned.

Inputs:
- HTTP GET request
- Flask-Login's "current_user" object

Flow:
1. Retrieve the current user object.
2. Query the database for all deposits, withdrawals, and interest earned by the user.
3. Calculate the total amount of deposits, withdrawals, and interest earned.
4. Create a context dictionary with the user object and the transaction history data.
5. Render the "transaction/index.html" template with the context data.

Outputs:
- Rendered HTML template displaying the user's transaction history, including deposits, withdrawals, and interest earned.

Additional aspects:
- The function is decorated with the "@transaction.route" and "@login_required" decorators, indicating that it is a view function and requires authentication.
- The function uses the "sum" function to calculate the total amount of deposits, withdrawals, and interest earned.
- The function uses a context dictionary to pass data to the HTML template.
"""


class TestIndex:
    # Tests that the function returns a rendered template with the user's transaction history and calculates the sum of deposits, withdrawals, and interests for a logged-in user with transactions.
    def test_happy_path(self, client, logged_in_user):
        response = client.get("/transaction/index")
        assert response.status_code == 200
        assert b"Transaction History" in response.data
        assert logged_in_user.username.encode() in response.data
        assert b"Deposit" in response.data
        assert b"Withdrawal" in response.data
        assert b"Interest" in response.data

    # Tests that the function works correctly with a mock database.
    def test_mock_database(self, client, mocker, logged_in_user):
        mock_deposit = mocker.Mock(amount=100)
        mock_withdrawal = mocker.Mock(amount=50)
        mock_interest = mocker.Mock(amount=10)
        mocker.patch(
            "app.transaction.Deposit.query.filter_by", return_value=[mock_deposit]
        )
        mocker.patch(
            "app.transaction.Withdrawal.query.filter_by", return_value=[mock_withdrawal]
        )
        mocker.patch(
            "app.transaction.Interest.query.filter_by", return_value=[mock_interest]
        )
        response = client.get("/transaction/index")
        assert response.status_code == 200
        assert b"Transaction History" in response.data
        assert logged_in_user.username.encode() in response.data
        assert b"Deposit" in response.data
        assert b"Withdrawal" in response.data
        assert b"Interest" in response.data
        assert b"100" in response.data
        assert b"50" in response.data
        assert b"10" in response.data

    # Tests that the function redirects to the login page for a user who is not logged in.
    def test_not_logged_in(self, client):
        response = client.get("/transaction/index")
        assert response.status_code == 302
        assert b"Redirecting..." in response.data

    # Tests that the function handles a database error gracefully and returns an error message.
    def test_database_error(self, client, mocker, logged_in_user):
        mocker.patch(
            "app.transaction.Deposit.query.filter_by",
            side_effect=Exception("Database Error"),
        )
        response = client.get("/transaction/index")
        assert response.status_code == 500
        assert b"Database Error" in response.data

    # Tests that the function returns a rendered template with zero transactions and zero sums for a logged-in user with no transactions.
    def test_no_transactions(self, client, logged_in_user):
        response = client.get("/transaction/index")
        assert response.status_code == 200
        assert b"Transaction History" in response.data
        assert logged_in_user.username.encode() in response.data
        assert b"No transactions found." in response.data
        assert b"Deposit" not in response.data
        assert b"Withdrawal" not in response.data
        assert b"Interest" not in response.data

    # Tests that the function handles pagination correctly for a user with a large number of transactions.
    def test_pagination(self, client, mocker, logged_in_user):
        mock_transactions = [mocker.Mock(amount=i) for i in range(50)]
        mocker.patch(
            "app.transaction.Deposit.query.filter_by", return_value=mock_transactions
        )
        mocker.patch(
            "app.transaction.Withdrawal.query.filter_by", return_value=mock_transactions
        )
        mocker.patch(
            "app.transaction.Interest.query.filter_by", return_value=mock_transactions
        )
        response = client.get("/transaction/index?page=2")
        assert response.status_code == 200
        assert b"Transaction History" in response.data
        assert logged_in_user.username.encode() in response.data
        assert b"Deposit" in response.data
        assert b"Withdrawal" in response.data
        assert b"Interest" in response.data
        assert b"0" not in response.data
        assert b"49" not in response.data
        assert b"50" in response.data

    # Tests that a valid form creates a deposit, updates the user's account balance, and sets the initial deposit date if not previously set.
    def test_deposit_view_valid_form(self, client, user):
        with client.login(user) as client:
            response = client.post(
                url_for("transaction.deposit_view"),
                data={"amount": 100, "currency": "USD"},
                follow_redirects=True,
            )
            assert response.status_code == 200
            assert Deposit.query.filter_by(user_id=user.id).first().amount == 123
            assert user.account.balance == 123
            assert user.account.initial_deposit_date is not None
            assert b"You Have Deposited 123 USD" in response.data

    # Tests that the deposit amount is correctly converted to the selected currency before being added to the user's account balance.
    def test_deposit_view_currency_conversion(self, client, user, mocker):
        mocker.patch(
            "app.transactions.views.convert_currency", return_value=123, autospec=True
        )
        with client.login(user) as client:
            response = client.post(
                url_for("transaction.deposit_view"),
                data={"amount": 100, "currency": "USD"},
                follow_redirects=True,
            )
            assert response.status_code == 200
            assert Deposit.query.filter_by(user_id=user.id).first().amount == 100
            assert user.account.balance == 123

    # Tests that an invalid form does not create a deposit, and error messages are displayed.
    def test_deposit_view_invalid_form(self, client, user):
        with client.login(user) as client:
            response = client.post(
                url_for("transaction.deposit_view"),
                data={"amount": "", "currency": ""},
                follow_redirects=True,
            )
            assert response.status_code == 200
            assert Deposit.query.filter_by(user_id=user.id).first() is None
            assert user.account.balance == 0
            assert b"This field is required." in response.data

    # Tests that large deposit amounts that may exceed database limits are handled correctly.
    def test_deposit_view_large_deposit_amount(self, client, user):
        with client.login(user) as client:
            response = client.post(
                url_for("transaction.deposit_view"),
                data={
                    "amount": 999999999999999999999999999999999999,
                    "currency": "CZK",
                },
                follow_redirects=True,
            )
            assert response.status_code == 200
            assert Deposit.query.filter_by(user_id=user.id).first() is None
            assert user.account.balance == 0
            assert b"Invalid value." in response.data

    # Tests that a flash message is displayed with the correct deposit amount and currency after a successful deposit.
    def test_deposit_view_flash_message(self, client, user):
        with client.login(user) as client:
            response = client.post(
                url_for("transaction.deposit_view"),
                data={"amount": 100, "currency": "USD"},
                follow_redirects=True,
            )
            assert response.status_code == 200
            assert b"You Have Deposited 123 USD" in response.data

    # Tests that the user is redirected to the index page after a successful deposit.
    def test_deposit_view_redirect(self, client, user):
        with client.login(user) as client:
            response = client.post(
                url_for("transaction.deposit_view"),
                data={"amount": 100, "currency": "USD"},
                follow_redirects=False,
            )
            assert response.status_code == 302
            assert response.location == url_for("main.index", _external=True)

    # Tests that a valid withdrawal form submission successfully adds the withdrawal amount to the database and deducts it from the user's account balance.
    def test_withdrawal_view_success(self, client, user):
        # Mock get_currency_exchange_rate function to always return 1
        with patch("app.transactions.views.get_currency_exchange_rate", return_value=1):
            # Login user
            client.post("/login", data={"email": user.email, "password": "password"})

            # Submit valid withdrawal form
            response = client.post(
                "/transaction/withdrawal", data={"amount": 100, "currency": "USD"}
            )

            # Check that withdrawal was added to database and user's balance was updated
            assert Withdrawal.query.filter_by(user_id=user.id).first().amount == 100
            assert user.account.balance == 900

            # Check that user is redirected to index page
            assert response.status_code == 302
            assert response.location == url_for("transaction.index", _external=True)

    # Tests that a flash message is displayed upon successful withdrawal.
    def test_withdrawal_view_flash_message(self, client, user):
        # Mock get_currency_exchange_rate function to always return 1
        with patch("app.transactions.views.get_currency_exchange_rate", return_value=1):
            # Login user
            client.post("/login", data={"email": user.email, "password": "password"})

            # Submit valid withdrawal form
            response = client.post(
                "/transaction/withdrawal", data={"amount": 100, "currency": "USD"}
            )

            # Check that success flash message is displayed
            assert b"You Have Withdraw 100 USD" in response.data

    # Tests that a user cannot withdraw more than their account balance.
    def test_withdrawal_view_insufficient_funds(self, client, user):
        # Mock get_currency_exchange_rate function to always return 1
        with patch("app.transactions.views.get_currency_exchange_rate", return_value=1):
            # Login user
            client.post("/login", data={"email": user.email, "password": "password"})

            # Submit withdrawal form with amount greater than user's balance
            response = client.post(
                "/transaction/withdrawal", data={"amount": 1000, "currency": "USD"}
            )

            # Check that withdrawal was not added to database and user's balance was not updated
            assert not Withdrawal.query.filter_by(user_id=user.id).first()
            assert user.account.balance == 1000

            # Check that error message is displayed
            assert b"You Can Not Withdraw More Than Your Balance." in response.data

    # Tests that a user cannot withdraw 0 or a negative amount.
    def test_withdrawal_view_zero_or_negative_amount(self, client, user):
        # Mock get_currency_exchange_rate function to always return 1
        with patch("app.transactions.views.get_currency_exchange_rate", return_value=1):
            # Login user
            client.post("/login", data={"email": user.email, "password": "password"})

            # Submit withdrawal form with amount of 0
            response = client.post(
                "/transaction/withdrawal", data={"amount": 0, "currency": "USD"}
            )

            # Check that withdrawal was not added to database and user's balance was not updated
            assert not Withdrawal.query.filter_by(user_id=user.id).first()
            assert user.account.balance == 1000

            # Check that error message is displayed
            assert b"This field is required." in response.data

            # Submit withdrawal form with negative amount
            response = client.post(
                "/transaction/withdrawal", data={"amount": -100, "currency": "USD"}
            )

            # Check that withdrawal was not added to database and user's balance was not updated
            assert not Withdrawal.query.filter_by(user_id=user.id).first()
            assert user.account.balance == 1000

            # Check that error message is displayed
            assert b"Amount must be greater than or equal to 1." in response.data

    # Tests that the user's selected currency is converted to CZK before being added to the database.
    def test_withdrawal_view_currency_conversion(self, client, user):
        # Mock get_currency_exchange_rate function to always return 2
        with patch("app.transactions.views.get_currency_exchange_rate", return_value=2):
            # Login user
            client.post("/login", data={"email": user.email, "password": "password"})

            # Submit valid withdrawal form with currency other than CZK
            response = client.post(
                "/transaction/withdrawal", data={"amount": 100, "currency": "USD"}
            )

            # Check that withdrawal was added to database with converted amount and user's balance was updated
            assert Withdrawal.query.filter_by(user_id=user.id).first().amount == 200
            assert user.account.balance == 800

            # Check that success flash message is displayed with converted currency
            assert b"You Have Withdraw 200 CZK" in response.data

    # Tests that an invalid form submission does not add a withdrawal to the database or update the user's account balance.
    def test_withdrawal_view_invalid_form_data(self, client, user):
        # Mock get_currency_exchange_rate function to always return 1
        with patch("app.transactions.views.get_currency_exchange_rate", return_value=1):
            # Login user
            client.post("/login", data={"email": user.email, "password": "password"})

            # Submit invalid withdrawal form
            response = client.post(
                "/transaction/withdrawal", data={"amount": "abc", "currency": "USD"}
            )

            # Check that withdrawal was not added to database and user's balance was not updated
            assert not Withdrawal.query.filter_by(user_id=user.id).first()
            assert user.account.balance == 1000

            # Check that error message is displayed
            assert b"Invalid integer value." in response.data

    # Tests that the function returns the correct converted amount for a valid amount and currency code.
    def test_happy_path_valid_amount_and_currency_code(self, mocker):
        mocker.patch("app.cnb_requests.get_currency_exchange_rate", return_value=1.5)
        assert convert_currency(100, "USD") == 150

    # Tests that the function raises a ValueError for an invalid currency code.
    def test_edge_case_invalid_currency_code(self, mocker):
        mocker.patch("app.cnb_requests.get_currency_exchange_rate", return_value=None)
        with pytest.raises(ValueError):
            convert_currency(100, "XYZ")

    # Tests that the function returns 0 for an amount of 0.
    def test_edge_case_amount_as_zero(self, mocker):
        mocker.patch("app.cnb_requests.get_currency_exchange_rate", return_value=1.5)
        assert convert_currency(0, "USD") == 0

    # Tests that the function rounds the converted amount to the nearest integer.
    def test_general_behavior_rounding(self, mocker):
        mocker.patch("app.cnb_requests.get_currency_exchange_rate", return_value=1.333)
        assert convert_currency(100, "EUR") == 133

    # Tests that the function returns a negative converted amount for a negative amount input.
    def test_edge_case_amount_as_negative_number(self, mocker):
        mocker.patch("app.cnb_requests.get_currency_exchange_rate", return_value=1.5)
        assert convert_currency(-100, "USD") == -150

    # Tests that the function returns 0 for a currency code with an exchange rate of 0.
    def test_edge_case_currency_code_with_exchange_rate_as_zero(self, mocker):
        mocker.patch("app.cnb_requests.get_currency_exchange_rate", return_value=0)
        assert convert_currency(100, "JPY") == 0
